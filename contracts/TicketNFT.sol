// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import "./libs/access/AccessControl.sol";
import "./libs/utils/Context.sol";
import "./libs/utils/Counters.sol";
import "./libs/token/ERC1155/ERC1155Burnable.sol";
import "./libs/token/ERC1155/ERC1155Pausable.sol";
import "./libs/token/ERC1155/ERC1155.sol";

/**
 * @dev {ERC1155} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a admin role that allows for token creating
 *  - a minter role that allows for token minting
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 */
contract TicketNFT is Context, AccessControl, ERC1155Burnable, ERC1155Pausable {
    using Counters for Counters.Counter;

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    struct TicketInfo {
        uint256 tokenId;
        uint256 price;
        uint8 rarity;
    }

    //To make the variable rarities behave like an enum type, we use an incrementing variable to control the value of the enum
    uint8 public rarityIncrementer;
    //used as an extensible enum type
    mapping(uint8 => string) public rarities;

    mapping(uint256 => TicketInfo) public ticketInfo;

    Counters.Counter private _idTracker;

    event TicketCreated(address indexed creator, uint256 indexed tokenId);
    event TicketUpdated(address indexed updater, uint256 indexed tokenId);
    event RarityAdded(uint8 key, string value);

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC1155-tokenURI}.
     */
    constructor() public ERC1155("") {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

        _setupRole(MINTER_ROLE, _msgSender());

        // token id start from 1
        _idTracker.increment();
    }

    modifier tokenExists(uint256 _tokenId) {
        require(
            ticketInfo[_tokenId].tokenId > 0,
            "TicketNFT: ticket does not exist"
        );
        _;
    }

    modifier multipleTokenExists(uint256[] memory _tokenIds) {
        uint256 length = _tokenIds.length;
        for (uint256 i = 0; i < length; ++i) {
            uint256 _tokenId = _tokenIds[i];
            require(
                ticketInfo[_tokenId].tokenId > 0,
                "TicketNFT: ticket does not exist"
            );
        }
        _;
    }

    modifier rarityIsValid(uint8 _rarity) {
        require(
            bytes(rarities[_rarity]).length > 0,
            "TicketNFT: rarity is not valid"
        );
        _;
    }

    modifier onlyAdmin {
        require(
            hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),
            "TicketNFT: caller is not admin"
        );
        _;
    }

    modifier onlyMinter {
        require(
            hasRole(MINTER_ROLE, _msgSender()),
            "TicketNFT: caller is not minter"
        );
        _;
    }
    
    function getTicketInfo(uint256 _tokenId)
        public
        tokenExists(_tokenId)
        view
        returns (
            uint256,
            uint256,
            string memory
        )
    {
        TicketInfo memory info = ticketInfo[_tokenId];
        return (info.tokenId, info.price, rarities[info.rarity]);
    }

    /**
     * @dev Creates a new token for `owner`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC1155-TransferSingle} event)
     *
     * See {ERC115-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `DEFAULT_ADMIN_ROLE`.
     */
    function createTicket(uint256 _price, uint8 _rarity)
        external
        onlyAdmin
        rarityIsValid(_rarity)
    {
        // We cannot just use balanceOf to create the new tokenId because tokens
        // can be burned (destroyed), so we need a separate counter.
        uint256 _id = _idTracker.current();
        ticketInfo[_id] = TicketInfo({
            tokenId: _id,
            price: _price,
            rarity: _rarity
        });
        _idTracker.increment();

        emit TicketCreated(_msgSender(), _id);
    }

    /**
     * @dev Mint `amount` tokens of token type `tokenId` for `owner`
     *
     * See {ERC115-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(
        address _owner,
        uint256 _tokenId,
        uint256 _amount
    ) public onlyMinter tokenExists(_tokenId) {
        _mint(_owner, _tokenId, _amount, "");
    }

    /**
     * @dev batch-operations[Batched] version of {_mint}
     *
     * See {ERC115-_mintBatch}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mintBatch(
        address _owner,
        uint256[] memory _tokenIds,
        uint256[] memory _amounts
    ) public onlyMinter multipleTokenExists(_tokenIds) {
        _mintBatch(_owner, _tokenIds, _amounts, "");
    }

    /**
     * @dev Changes in token price and rarity
     *
     * Requirements:
     *
     * - the caller must have the `DEFAULT_ADMIN_ROLE`.
     */
    function updateTicket(
        uint256 _tokenId,
        uint256 _price,
        uint8 _rarity
    ) external onlyAdmin tokenExists(_tokenId) rarityIsValid(_rarity) {
        TicketInfo storage ticket = ticketInfo[_tokenId];
        ticket.price = _price;
        ticket.rarity = _rarity;

        emit TicketUpdated(_msgSender(), _tokenId);
    }

    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual override(ERC1155, ERC1155Pausable) {
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    }

    /**
     * @dev External function to set the base URI for all token IDs.
     *
     * See {ERC1155-_setURI}
     *
     * Requirements:
     *
     * - the caller must have the `DEFAULT_ADMIN_ROLE`.
     */
    function setBaseURI(string memory _baseURI) external onlyAdmin {
        _setURI(_baseURI);
    }

    /**
     * @dev Currently Enum type is not extensible, so we will use mapping(uint8 => string) as an Enum type.
     * This function allows us to extend our Enum
     *
     * Requirements:
     *
     * - the caller must have the `DEFAULT_ADMIN_ROLE`.
     */
    function addRarity(string calldata _rarity) external onlyAdmin {
        // we want to use keys of rarities like enum type
        // so we will control the value representing enum type
        rarityIncrementer = rarityIncrementer + 1;
        rarities[rarityIncrementer] = _rarity;
        emit RarityAdded(rarityIncrementer, _rarity);
    }

    /**
     * @dev Returns the number of tickets created.
     *
     * Requirements:
     *
     * - can be called by anyone.
     */
    function ticketLength() external view returns (uint256) {
        return _idTracker.current() - 1;
    }
}
